
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>with_PA_rate_vals</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-08-04"><meta name="DC.source" content="with_PA_rate_vals.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput">clear;

<span class="comment">% defining constants</span>
hbar = 6.626e-34 / (2*pi); <span class="comment">% plank's constant</span>
lambda = 804.3e-9; <span class="comment">% wavelength</span>
kr = (2*pi)/lambda;
kx = linspace(-5*kr, 5*kr, 100);
m = 87*0.33*(1.66e-27)*7e4; <span class="comment">% mass</span>
Er = ((hbar^2)*(kr^2))/(2*m);
delta = 0;
delta1 = (-2*Er)/hbar;
delta2 = (-2*Er)/hbar;
omega = (4.85*Er)/hbar;
epsilon = 0;
theta1 = 0;
theta2 = 0;

<span class="comment">%Defining empty lists and arrays that will be filled</span>
E1 = zeros(3, length(kx));
E2 = zeros(3, length(kx));
Eb1 = zeros(3, length(kx));
Eb2 = zeros(3, length(kx));
Erf = zeros(3, length(kx));
Ebrf = zeros(3, length(kx));
Edrf = zeros(3, length(kx));
Ebdrf = zeros(3, length(kx));
pa = [];
pa2 = [];
pa3 = [];
pa1d = [];
pa2d = [];
pa3d = [];
pa_int = [];

<span class="comment">%finding the Hamiltonian's eigenvalues</span>
<span class="keyword">for</span> ii = 1:length(kx)
    <span class="comment">% H1 = Raman w/o Detuning, H2 = Raman w/Detuning</span>
    <span class="comment">% lowercase b indicates basis state</span>
    H1 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta, omega/2, 0;
      omega/2, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, omega/2;
      0, omega/2, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta];
    H2 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta2, omega/2, 0;
      omega/2, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, omega/2;
      0, omega/2, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta2];
    E1(:,ii) = eig(H1);
    E2(:,ii) = eig(H2);
    Hb1 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta, 0, 0;
      0, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, 0;
      0, 0, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta];
    Hb2 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta2, 0, 0;
      0, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, 0;
      0, 0, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta2];
    Eb1(:,ii) = eig(Hb1);
    Eb2(:,ii) = eig(Hb2);
    <span class="comment">% Hrf = rf w/o detuning, Hdrf = rf w/detuning</span>
    Hrf = [((hbar/(2*m))*kx(ii)^2)-delta1, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), ((hbar/(2*m))*kx(ii)^2)-epsilon, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), ((hbar/(2*m))*kx(ii)^2)+delta2];
    Erf(:,ii) = eig(Hrf);
    Hbrf = [((hbar/(2*m))*kx(ii)^2)-delta1, 0, 0;
        0, ((hbar/(2*m))*kx(ii)^2)-epsilon, 0;
        0, 0, ((hbar/(2*m))*kx(ii)^2)+delta2];
    Ebrf(:,ii) = eig(Hbrf);
    Hdrf = [((hbar/(2*m))*kx(ii)^2)-0, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), ((hbar/(2*m))*kx(ii)^2)-epsilon, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), ((hbar/(2*m))*kx(ii)^2)+0];
    Edrf(:,ii) = eig(Hdrf);
    Hbdrf = [((hbar/(2*m))*kx(ii)^2)-0, 0, 0;
        0, ((hbar/(2*m))*kx(ii)^2)-epsilon, 0;
        0, 0, ((hbar/(2*m))*kx(ii)^2)+0];
    Ebdrf(:,ii) = eig(Hbdrf);
<span class="keyword">end</span>

<span class="comment">%finding the minimum points on the lowest band and checking for doubles</span>
<span class="comment">%(due to symmetry)</span>
checker1 = 10;
checker2 = 10;
checkerrf = 0;
checkerdrf = 0;
<span class="keyword">for</span> ii = 1:length(kx)
    <span class="keyword">if</span> checker1 &gt; E1(1, ii)
        checker1 = E1(1, ii);
        loc1 = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checker1 == E1(1, ii)
        loc1b = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checker2 &gt; E2(1, ii)
        checker2 = E2(1, ii);
        loc2 = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checker2 == E2(1, ii)
        loc2b = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checkerrf &gt; Erf(1, ii)
        checkerrf = Erf(1, ii);
        locrf = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checkerrf == Erf(1, ii)
        locrfb = ii;
    <span class="keyword">end</span>
     <span class="keyword">if</span> checkerdrf &gt; Edrf(1, ii)
        checkerdrf = Edrf(1, ii);
        locdrf = ii;
    <span class="keyword">end</span>
    <span class="keyword">if</span> checkerdrf == Edrf(1, ii)
        locdrfb = ii;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% calculating the PA rate and defining variables that are only used here</span>
kx_temp = kr;
theta1 = linspace(0, 2*pi, 30);
delta1 = 0;
delta2_detuned = delta1;
omega1 = omega; <span class="comment">%if omega is set close to 100 it matches Felicia's output</span>
omega2 = omega1;
<span class="keyword">for</span> ii = 1:30
    Hrf2 = [((hbar/(2*m))*kx_temp^2)-delta1, (1/2)*omega1*(exp(1i*theta1(ii))), 0;
        (1/2)*omega1*(exp(-1i*theta1(ii))), ((hbar/(2*m))*kx_temp^2)-epsilon, (1/2)*omega2*(exp(1i*theta2));
        0, (1/2)*omega2*(exp(-1i*theta2)), ((hbar/(2*m))*kx_temp^2)+delta2_detuned];
    [Eigvec0,b] = eig(Hrf2);
    pa_temp = (conj(Eigvec0(2,1)^2))*((Eigvec0(2,1)^2)) + 4*((conj(Eigvec0(1,1)*Eigvec0(3,1)))*(Eigvec0(1,1)*Eigvec0(3,1))) - 4*real((Eigvec0(2,1))^2 * conj(Eigvec0(1,1)) * conj(Eigvec0(3,1)));
    pa_int_temp = (conj(Eigvec0(2,1)^2)*(Eigvec0(2,1)^2)) + 4*((conj(Eigvec0(1,1)*Eigvec0(3,1)))*(Eigvec0(1,1)*Eigvec0(3,1)));
    pa = cat(2, pa, pa_temp);
    pa_int = cat(2, pa_int, pa_int_temp);
<span class="keyword">end</span>


<span class="comment">%plotting the energy-momentum dispersion relation and pa rate outputs</span>
figure;
plot(kx/kr, E1, <span class="string">'LineWidth'</span>, 2.5); hold <span class="string">on</span>;
plot(kx/kr, Eb1, <span class="string">"k--"</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(loc1)/kr, checker1, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(loc1b)/kr, checker1, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
xlabel(<span class="string">'$$\frac{k_x}{k_r}$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylabel(<span class="string">'Energy $$(E_r)$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
title(<span class="string">'Energy-Momentum Dispersion Curves for $$\delta=0$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 20);
ylim([-4 10]);
grid <span class="string">on</span>;

figure;
plot(kx/kr, E2, <span class="string">'LineWidth'</span>, 2.5); hold <span class="string">on</span>;
plot(kx/kr, Eb2, <span class="string">"k--"</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(loc2)/kr, checker2, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
xlabel(<span class="string">'$$\frac{k_x}{k_r}$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylabel(<span class="string">'Energy $$(E_r)$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
title(<span class="string">'Energy-Momentum Dispersion Curves for $$\hbar * \delta =-2E_r$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 20);
ylim([-4 10]);
grid <span class="string">on</span>;

figure;
plot(kx/kr, Erf, <span class="string">'LineWidth'</span>, 2.5); hold <span class="string">on</span>;
plot(kx/kr, Ebrf, <span class="string">"k--"</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(locrf)/kr, checkerrf, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(locrfb)/kr, checkerrf, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
xlabel(<span class="string">'$$\frac{k_x}{k_r}$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylabel(<span class="string">'Energy $$(E_r)$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
title(<span class="string">'Energy-Momentum Dispersion Curves for Detuned RF-Coupling Scheme'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylim([-5 10]);
grid <span class="string">on</span>;

figure;
plot(kx/kr, Edrf, <span class="string">'LineWidth'</span>, 2.5); hold <span class="string">on</span>;
plot(kx/kr, Ebdrf, <span class="string">"k--"</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(locdrf)/kr, checkerdrf, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
plot(kx(locdrfb)/kr, checkerdrf, <span class="string">'k*'</span>, <span class="string">'LineWidth'</span>, 2.5);
xlabel(<span class="string">'$$\frac{k_x}{k_r}$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylabel(<span class="string">'Energy $$(E_r)$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
title(<span class="string">'Energy-Momentum Dispersion Curves for RF-Coupling Scheme'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylim([-5 20]);
grid <span class="string">on</span>;

figure;
plot(theta1 - theta2, pa, <span class="string">'LineWidth'</span>, 2.5); hold <span class="string">on</span>;
plot(theta1 - theta2, pa_int, <span class="string">'LineWidth'</span>, 2.5);
xlabel(<span class="string">'$$\theta_1 - \theta_2$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
ylabel(<span class="string">'$$\frac{k_{sup}}{k_{0,0}}$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
title(<span class="string">'RF Normalized PA Rate Dependence on $$\theta_1 - \theta_2$$'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>, <span class="string">'FontSize'</span>, 18);
legend(<span class="string">'Interference'</span>,<span class="string">'No Interference'</span>, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>)
xticks(0:(pi/4):2*pi);
xlim([0 2*pi]);
grid <span class="string">on</span>;

<span class="comment">% making all of my variables symbolic so the eigenstates and PA rate can be</span>
<span class="comment">% solved analytically</span>
kx = 0;
delta1 = 0;
delta2 = 0;
syms <span class="string">hbar</span>
syms <span class="string">m</span>
syms <span class="string">omega1</span>
syms <span class="string">omega2</span>
syms <span class="string">theta1</span>
syms <span class="string">epsilon</span>
syms <span class="string">theta2</span>
<span class="comment">%analytically defining the matrix</span>
Hrf_analytic = sym([0, (1/2)*omega1*(exp(1i*theta1)), 0;
        (1/2)*omega1*(exp(-1i*theta1)), 0, (1/2)*omega2*(exp(1i*theta2));
        0, (1/2)*omega2*(exp(-1i*theta2)), 0]);
[Erf_analytic, a] = eig(Hrf_analytic);
disp(<span class="string">'omega 1 != omega 2'</span>);
disp(<span class="string">'Eigenvalues:'</span>);
disp(a);
disp(<span class="string">'bare state representation:'</span>);
bsr = Erf_analytic(1,1) * a(1,1) + Erf_analytic(2,1) * a(2,2) + Erf_analytic(3,1) * a(3,3);
disp(bsr);
disp(<span class="string">'Eigenstates:'</span>);
disp(Erf_analytic);
pa_analytic = (conj(Erf_analytic(2,1))^2)*((Erf_analytic(2,1)^2)) + 4*((conj(Erf_analytic(1,1)*Erf_analytic(3,1)))*(Erf_analytic(1,1)*Erf_analytic(3,1))) - 4*real(Erf_analytic(2,1))^2 * Erf_analytic(1,1) * Erf_analytic(3,1);
disp(<span class="string">'PA Rate:'</span>);
disp(pa_analytic);
pa_a = rewrite(pa_analytic, <span class="string">"sincos"</span>);
disp(pa_a);
<span class="comment">% so it looks like the first and second expressions depend on theta 1 - theta 2</span>
<span class="comment">% because those two values are included in those expressions</span>

<span class="comment">%analytically defining the matrix for omega 1 = omega 2</span>
syms <span class="string">omega</span>
Hrf_analytic = sym([0, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), 0, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), 0]);
[Erf_analytic, a] = eig(Hrf_analytic);
disp(<span class="string">'omega 1 = omega 2'</span>);
disp(<span class="string">'Eigenvalues:'</span>);
disp(a);
disp(<span class="string">'bare state representation:'</span>);
bsr = Erf_analytic(1,1) * a(1,1) + Erf_analytic(2,1) * a(2,2) + Erf_analytic(3,1) * a(3,3);
disp(bsr);
disp(<span class="string">'Eigenstates:'</span>);
disp(Erf_analytic);
pa_analytic = (conj(Erf_analytic(2,1))^2)*((Erf_analytic(2,1)^2)) + 4*((conj(Erf_analytic(1,1)*Erf_analytic(3,1)))*(Erf_analytic(1,1)*Erf_analytic(3,1))) - 4*real(Erf_analytic(2,1))^2 * Erf_analytic(1,1) * Erf_analytic(3,1);
disp(<span class="string">'PA Rate:'</span>);
disp(pa_analytic);
pa_a = rewrite(pa_analytic, <span class="string">"sincos"</span>);
disp(pa_a);
</pre><pre class="codeoutput">omega 1 != omega 2
Eigenvalues:
[0,                              0,                             0]
[0, -(omega1^2 + omega2^2)^(1/2)/2,                             0]
[0,                              0, (omega1^2 + omega2^2)^(1/2)/2]
 
bare state representation:
(omega1^2 + omega2^2)^(1/2)/2
 
Eigenstates:
[-(omega2*exp(theta1*1i)*exp(theta2*1i))/omega1,        (omega1*exp(theta1*1i)*exp(theta2*1i))/omega2,       (omega1*exp(theta1*1i)*exp(theta2*1i))/omega2]
[                                             0, -(exp(theta2*1i)*(omega1^2 + omega2^2)^(1/2))/omega2, (exp(theta2*1i)*(omega1^2 + omega2^2)^(1/2))/omega2]
[                                             1,                                                    1,                                                   1]
 
PA Rate:
(4*omega2*exp(theta1*1i)*exp(theta2*1i)*exp(-conj(theta1)*1i)*exp(-conj(theta2)*1i)*conj(omega2))/(omega1*conj(omega1))
 
(4*omega2*conj(omega2)*(cos(conj(theta1)) - sin(conj(theta1))*1i)*(cos(conj(theta2)) - sin(conj(theta2))*1i)*(cos(theta1) + sin(theta1)*1i)*(cos(theta2) + sin(theta2)*1i))/(omega1*conj(omega1))
 
omega 1 = omega 2
Eigenvalues:
[0,                  0,                 0]
[0, -(2^(1/2)*omega)/2,                 0]
[0,                  0, (2^(1/2)*omega)/2]
 
bare state representation:
(2^(1/2)*omega)/2
 
Eigenstates:
[-exp(theta1*1i)*exp(theta2*1i), exp(theta1*1i)*exp(theta2*1i), exp(theta1*1i)*exp(theta2*1i)]
[                             0,       -2^(1/2)*exp(theta2*1i),        2^(1/2)*exp(theta2*1i)]
[                             1,                             1,                             1]
 
PA Rate:
4*exp(theta1*1i)*exp(theta2*1i)*exp(-conj(theta1)*1i)*exp(-conj(theta2)*1i)
 
4*(cos(conj(theta1)) - sin(conj(theta1))*1i)*(cos(conj(theta2)) - sin(conj(theta2))*1i)*(cos(theta1) + sin(theta1)*1i)*(cos(theta2) + sin(theta2)*1i)
 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
clear;

% defining constants
hbar = 6.626e-34 / (2*pi); % plank's constant
lambda = 804.3e-9; % wavelength
kr = (2*pi)/lambda;
kx = linspace(-5*kr, 5*kr, 100);
m = 87*0.33*(1.66e-27)*7e4; % mass
Er = ((hbar^2)*(kr^2))/(2*m);
delta = 0;
delta1 = (-2*Er)/hbar;
delta2 = (-2*Er)/hbar;
omega = (4.85*Er)/hbar;
epsilon = 0;
theta1 = 0;
theta2 = 0;

%Defining empty lists and arrays that will be filled
E1 = zeros(3, length(kx));
E2 = zeros(3, length(kx));
Eb1 = zeros(3, length(kx));
Eb2 = zeros(3, length(kx));
Erf = zeros(3, length(kx));
Ebrf = zeros(3, length(kx));
Edrf = zeros(3, length(kx));
Ebdrf = zeros(3, length(kx));
pa = [];
pa2 = [];
pa3 = [];
pa1d = [];
pa2d = [];
pa3d = [];
pa_int = [];

%finding the Hamiltonian's eigenvalues
for ii = 1:length(kx)
    % H1 = Raman w/o Detuning, H2 = Raman w/Detuning
    % lowercase b indicates basis state
    H1 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta, omega/2, 0;
      omega/2, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, omega/2;
      0, omega/2, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta];
    H2 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta2, omega/2, 0;
      omega/2, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, omega/2;
      0, omega/2, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta2];
    E1(:,ii) = eig(H1);
    E2(:,ii) = eig(H2);
    Hb1 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta, 0, 0;
      0, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, 0;
      0, 0, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta];
    Hb2 = [(hbar/(2*m))*(kx(ii)+2*kr)^2 - delta2, 0, 0;
      0, ((hbar/(2*m))*(kx(ii)^2)) - epsilon, 0;
      0, 0, (hbar/(2*m))*(kx(ii)-2*kr)^2 + delta2];
    Eb1(:,ii) = eig(Hb1);
    Eb2(:,ii) = eig(Hb2);
    % Hrf = rf w/o detuning, Hdrf = rf w/detuning
    Hrf = [((hbar/(2*m))*kx(ii)^2)-delta1, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), ((hbar/(2*m))*kx(ii)^2)-epsilon, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), ((hbar/(2*m))*kx(ii)^2)+delta2];
    Erf(:,ii) = eig(Hrf);
    Hbrf = [((hbar/(2*m))*kx(ii)^2)-delta1, 0, 0;
        0, ((hbar/(2*m))*kx(ii)^2)-epsilon, 0;
        0, 0, ((hbar/(2*m))*kx(ii)^2)+delta2];
    Ebrf(:,ii) = eig(Hbrf);
    Hdrf = [((hbar/(2*m))*kx(ii)^2)-0, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), ((hbar/(2*m))*kx(ii)^2)-epsilon, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), ((hbar/(2*m))*kx(ii)^2)+0];
    Edrf(:,ii) = eig(Hdrf);
    Hbdrf = [((hbar/(2*m))*kx(ii)^2)-0, 0, 0;
        0, ((hbar/(2*m))*kx(ii)^2)-epsilon, 0;
        0, 0, ((hbar/(2*m))*kx(ii)^2)+0];
    Ebdrf(:,ii) = eig(Hbdrf);
end

%finding the minimum points on the lowest band and checking for doubles
%(due to symmetry)
checker1 = 10;
checker2 = 10;
checkerrf = 0;
checkerdrf = 0;
for ii = 1:length(kx)
    if checker1 > E1(1, ii)
        checker1 = E1(1, ii);
        loc1 = ii;
    end
    if checker1 == E1(1, ii)
        loc1b = ii;
    end
    if checker2 > E2(1, ii)
        checker2 = E2(1, ii);
        loc2 = ii;
    end
    if checker2 == E2(1, ii)
        loc2b = ii;
    end
    if checkerrf > Erf(1, ii)
        checkerrf = Erf(1, ii);
        locrf = ii;
    end
    if checkerrf == Erf(1, ii)
        locrfb = ii;
    end
     if checkerdrf > Edrf(1, ii)
        checkerdrf = Edrf(1, ii);
        locdrf = ii;
    end
    if checkerdrf == Edrf(1, ii)
        locdrfb = ii;
    end
end

% calculating the PA rate and defining variables that are only used here
kx_temp = kr;
theta1 = linspace(0, 2*pi, 30);
delta1 = 0;
delta2_detuned = delta1;
omega1 = omega; %if omega is set close to 100 it matches Felicia's output
omega2 = omega1;
for ii = 1:30
    Hrf2 = [((hbar/(2*m))*kx_temp^2)-delta1, (1/2)*omega1*(exp(1i*theta1(ii))), 0;
        (1/2)*omega1*(exp(-1i*theta1(ii))), ((hbar/(2*m))*kx_temp^2)-epsilon, (1/2)*omega2*(exp(1i*theta2));
        0, (1/2)*omega2*(exp(-1i*theta2)), ((hbar/(2*m))*kx_temp^2)+delta2_detuned];
    [Eigvec0,b] = eig(Hrf2);
    pa_temp = (conj(Eigvec0(2,1)^2))*((Eigvec0(2,1)^2)) + 4*((conj(Eigvec0(1,1)*Eigvec0(3,1)))*(Eigvec0(1,1)*Eigvec0(3,1))) - 4*real((Eigvec0(2,1))^2 * conj(Eigvec0(1,1)) * conj(Eigvec0(3,1)));
    pa_int_temp = (conj(Eigvec0(2,1)^2)*(Eigvec0(2,1)^2)) + 4*((conj(Eigvec0(1,1)*Eigvec0(3,1)))*(Eigvec0(1,1)*Eigvec0(3,1)));
    pa = cat(2, pa, pa_temp);
    pa_int = cat(2, pa_int, pa_int_temp);
end


%plotting the energy-momentum dispersion relation and pa rate outputs
figure;
plot(kx/kr, E1, 'LineWidth', 2.5); hold on;
plot(kx/kr, Eb1, "kREPLACE_WITH_DASH_DASH", 'LineWidth', 2.5);
plot(kx(loc1)/kr, checker1, 'k*', 'LineWidth', 2.5);
plot(kx(loc1b)/kr, checker1, 'k*', 'LineWidth', 2.5);
xlabel('$$\frac{k_x}{k_r}$$', 'Interpreter', 'latex', 'FontSize', 18);
ylabel('Energy $$(E_r)$$', 'Interpreter', 'latex', 'FontSize', 18);
title('Energy-Momentum Dispersion Curves for $$\delta=0$$', 'Interpreter', 'latex', 'FontSize', 20);
ylim([-4 10]);
grid on;

figure;
plot(kx/kr, E2, 'LineWidth', 2.5); hold on;
plot(kx/kr, Eb2, "kREPLACE_WITH_DASH_DASH", 'LineWidth', 2.5);
plot(kx(loc2)/kr, checker2, 'k*', 'LineWidth', 2.5);
xlabel('$$\frac{k_x}{k_r}$$', 'Interpreter', 'latex', 'FontSize', 18);
ylabel('Energy $$(E_r)$$', 'Interpreter', 'latex', 'FontSize', 18);
title('Energy-Momentum Dispersion Curves for $$\hbar * \delta =-2E_r$$', 'Interpreter', 'latex', 'FontSize', 20);
ylim([-4 10]);
grid on;

figure;
plot(kx/kr, Erf, 'LineWidth', 2.5); hold on;
plot(kx/kr, Ebrf, "kREPLACE_WITH_DASH_DASH", 'LineWidth', 2.5);
plot(kx(locrf)/kr, checkerrf, 'k*', 'LineWidth', 2.5);
plot(kx(locrfb)/kr, checkerrf, 'k*', 'LineWidth', 2.5);
xlabel('$$\frac{k_x}{k_r}$$', 'Interpreter', 'latex', 'FontSize', 18);
ylabel('Energy $$(E_r)$$', 'Interpreter', 'latex', 'FontSize', 18);
title('Energy-Momentum Dispersion Curves for Detuned RF-Coupling Scheme', 'Interpreter', 'latex', 'FontSize', 18);
ylim([-5 10]);
grid on;

figure;
plot(kx/kr, Edrf, 'LineWidth', 2.5); hold on;
plot(kx/kr, Ebdrf, "kREPLACE_WITH_DASH_DASH", 'LineWidth', 2.5);
plot(kx(locdrf)/kr, checkerdrf, 'k*', 'LineWidth', 2.5);
plot(kx(locdrfb)/kr, checkerdrf, 'k*', 'LineWidth', 2.5);
xlabel('$$\frac{k_x}{k_r}$$', 'Interpreter', 'latex', 'FontSize', 18);
ylabel('Energy $$(E_r)$$', 'Interpreter', 'latex', 'FontSize', 18);
title('Energy-Momentum Dispersion Curves for RF-Coupling Scheme', 'Interpreter', 'latex', 'FontSize', 18);
ylim([-5 20]);
grid on;

figure;
plot(theta1 - theta2, pa, 'LineWidth', 2.5); hold on;
plot(theta1 - theta2, pa_int, 'LineWidth', 2.5);
xlabel('$$\theta_1 - \theta_2$$', 'Interpreter', 'latex', 'FontSize', 18);
ylabel('$$\frac{k_{sup}}{k_{0,0}}$$', 'Interpreter', 'latex', 'FontSize', 18);
title('RF Normalized PA Rate Dependence on $$\theta_1 - \theta_2$$', 'Interpreter', 'latex', 'FontSize', 18);
legend('Interference','No Interference', 'Interpreter', 'latex')
xticks(0:(pi/4):2*pi);
xlim([0 2*pi]);
grid on;

% making all of my variables symbolic so the eigenstates and PA rate can be
% solved analytically
kx = 0;
delta1 = 0;
delta2 = 0;
syms hbar
syms m 
syms omega1
syms omega2
syms theta1
syms epsilon
syms theta2
%analytically defining the matrix
Hrf_analytic = sym([0, (1/2)*omega1*(exp(1i*theta1)), 0;
        (1/2)*omega1*(exp(-1i*theta1)), 0, (1/2)*omega2*(exp(1i*theta2));
        0, (1/2)*omega2*(exp(-1i*theta2)), 0]);
[Erf_analytic, a] = eig(Hrf_analytic);
disp('omega 1 != omega 2');
disp('Eigenvalues:');
disp(a);
disp('bare state representation:');
bsr = Erf_analytic(1,1) * a(1,1) + Erf_analytic(2,1) * a(2,2) + Erf_analytic(3,1) * a(3,3);
disp(bsr);
disp('Eigenstates:');
disp(Erf_analytic);
pa_analytic = (conj(Erf_analytic(2,1))^2)*((Erf_analytic(2,1)^2)) + 4*((conj(Erf_analytic(1,1)*Erf_analytic(3,1)))*(Erf_analytic(1,1)*Erf_analytic(3,1))) - 4*real(Erf_analytic(2,1))^2 * Erf_analytic(1,1) * Erf_analytic(3,1);
disp('PA Rate:');
disp(pa_analytic);
pa_a = rewrite(pa_analytic, "sincos");
disp(pa_a);
% so it looks like the first and second expressions depend on theta 1 - theta 2
% because those two values are included in those expressions

%analytically defining the matrix for omega 1 = omega 2
syms omega
Hrf_analytic = sym([0, (1/2)*omega*(exp(1i*theta1)), 0;
        (1/2)*omega*(exp(-1i*theta1)), 0, (1/2)*omega*(exp(1i*theta2));
        0, (1/2)*omega*(exp(-1i*theta2)), 0]);
[Erf_analytic, a] = eig(Hrf_analytic);
disp('omega 1 = omega 2');
disp('Eigenvalues:');
disp(a);
disp('bare state representation:');
bsr = Erf_analytic(1,1) * a(1,1) + Erf_analytic(2,1) * a(2,2) + Erf_analytic(3,1) * a(3,3);
disp(bsr);
disp('Eigenstates:');
disp(Erf_analytic);
pa_analytic = (conj(Erf_analytic(2,1))^2)*((Erf_analytic(2,1)^2)) + 4*((conj(Erf_analytic(1,1)*Erf_analytic(3,1)))*(Erf_analytic(1,1)*Erf_analytic(3,1))) - 4*real(Erf_analytic(2,1))^2 * Erf_analytic(1,1) * Erf_analytic(3,1);
disp('PA Rate:');
disp(pa_analytic);
pa_a = rewrite(pa_analytic, "sincos");
disp(pa_a);
##### SOURCE END #####
--></body></html>